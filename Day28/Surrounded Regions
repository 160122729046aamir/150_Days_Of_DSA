class Solution:
    def solve(self, board: List[List[str]]) -> None:
        rows=len(board)
        cols=len(board[0])
        path=set()
        a=0
        def dfs(r,c):
            if r<0 or c<0 or r>rows-1 or c>cols-1 or board[r][c]!='O':
                return False
            board[r][c]='T'
            dfs(r-1,c)
            dfs(r+1,c)
            dfs(r,c-1)
            dfs(r,c+1)
        for r in range(rows):
            for c in range(cols):
                if board[r][c]=='O' and (r in [0,rows-1] or c in [0,cols-1]):
                    dfs(r,c)
        for r in range(rows):
            for c in range(cols):
                if board[r][c]=='O':
                    board[r][c]='X'
        for r in range(rows):
            for c in range(cols):
                if board[r][c]=='T':
                    board[r][c]='O'
                
        return board


class Solution:
    def solve(self, board: List[List[str]]) -> None:
        rows=len(board)
        cols=len(board[0])
        path=set()
        a=0
        def bfs(r,c):
            stack=[(r,c)]
            directions=[(-1, 0), (1, 0), (0, -1), (0, 1)]
            while stack:
                row,col=stack.pop()
                for dr,dc in directions:
                    nr=row+dr
                    nc=col+dc
                    if nr in range(rows) and nc in range(cols) and board[nr][nc] == 'O':
                        board[nr][nc]='T'
                        stack.append((nr,nc))
        for r in range(rows):
            for c in range(cols):
                if board[r][c]=='O' and (r in [0,rows-1] or c in [0,cols-1]):
                    board[r][c]='T'
                    bfs(r,c)
        for r in range(rows):
            for c in range(cols):
                if board[r][c]=='O':
                    board[r][c]='X'
        for r in range(rows):
            for c in range(cols):
                if board[r][c]=='T':
                    board[r][c]='O'
                
        return board
